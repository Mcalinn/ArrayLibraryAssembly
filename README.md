# Array Library (ASM x86-64)

Небольшая динамическая библиотека на ассемблере для работы с массивом 32‑битных целых чисел (uint32_t). Реализовано: создание, добавление, вставка, удаление, вычисление суммы, поиск минимума/максимума и освобождение памяти. 

Библиотека поддерживает обе платформы:
- **Windows**: Win64 ABI (аргументы в RCX/RDX/R8/R9, shadow space 32 байта)
- **Linux**: SysV ABI (аргументы в RDI/RSI/RDX/RCX/R8/R9)

Код автоматически адаптируется к целевой платформе через условную компиляцию (`%if IS_WIN64`).

## Структура в памяти
```
offset 0  (8 байт)  size     (uint64_t, текущее количество элементов)
offset 8  (8 байт)  capacity (uint64_t, максимально доступное кол-во элементов без расширения)
offset 16 (данные)  data[]   (последовательность uint32_t чисел)
```

## Базовые типы
```
Array* указывает на начало блока (size по смещению 0).
```

## Реализованные функции (Windows сигнатуры)
Ниже показано, какие регистры занимают параметры в Windows x64 ABI.

Функции (Windows x64 ABI):

- new_array(capacity)
	- Назначение: создать новый массив (capacity=0 => 4 по умолчанию)
	- Параметры: RCX = capacity (uint64)
	- Возврат: RAX = Array* или 0 при ошибке

- free_array(ptr)
	- Назначение: освободить память массива
	- Параметры: RCX = Array*
	- Возврат: нет

- resize_array(old_ptr, new_capacity)
	- Назначение: изменить емкость, возможно переместив буфер
	- Параметры: RCX = старый Array*, RDX = новая capacity (uint64)
	- Возврат: RAX = новый Array* или 0 при ошибке

- push_element(&ptr, value)
	- Назначение: добавить элемент в конец; при нехватке места расширяет
	- Параметры: RCX = адрес переменной с указателем (Array**), RDX = значение (uint32)
	- Возврат: нет

- insert_at(&ptr, index, value)
	- Назначение: вставить элемент по индексу (если index > size, вставка в конец)
	- Параметры: RCX = Array**, RDX = index (uint64), R8D = value (uint32)
	- Возврат: нет

- remove_at(&ptr, index)
	- Назначение: удалить элемент по индексу (ничего не делает если index >= size)
	- Параметры: RCX = Array**, RDX = index (uint64)
	- Возврат: нет

- sum_array(ptr)
	- Назначение: посчитать сумму всех элементов
	- Параметры: RCX = Array*
	- Возврат: RAX = сумма (uint64)

- min_array(ptr)
	- Назначение: найти минимальный элемент (0 если пусто/NULL)
	- Параметры: RCX = Array*
	- Возврат: RAX = min (uint32)

- max_array(ptr)
	- Назначение: найти максимальный элемент (0 если пусто/NULL)
	- Параметры: RCX = Array*
	- Возврат: RAX = max (uint32)

Примечание: `fill_array`, `find_value`, `copy_array`, `sort_array` упомянуты ранее, но в текущем коде не реализованы / экспортируются дважды (артефакт). Если нужны — их можно добавить аналогично.

## Реализация на Linux
В `main_linux.asm` используются регистры SysV ABI:
| Функция      | Параметры (Linux)                       |
|--------------|-----------------------------------------|
| new_array    | RDI = capacity                          |
| push_element | RDI = Array**, ESI = value              |
| insert_at    | RDI = Array**, RSI = index, EDX = value |
| remove_at    | RDI = Array**, RSI = index              |
| sum_array    | RDI = Array*                            |
| min_array    | RDI = Array*                            |
| max_array    | RDI = Array*                            |
| free_array   | RDI = Array*                            |

Все функции в `array_lib.asm` автоматически определяют формат вывода (`__OUTPUT_FORMAT__`) и используют соответствующие регистры.

## Добавление / изменение данных (Windows)
В `main_windows.asm` сейчас последовательно выполняется:
```
push_element(&array_ptr, 10)
push_element(&array_ptr, 20)
push_element(&array_ptr, 30)
remove_at(&array_ptr, 1)        ; удаляет значение 20
insert_at(&array_ptr, 1, 25)    ; вставляет 25 на позицию 1
sum_array(array_ptr)
min_array(array_ptr)
max_array(array_ptr)
free_array(array_ptr)
```
Чтобы протестировать другие значения:
1. Откройте `main_windows.asm`.
2. Найдите блоки:
	- `mov rdx, 10` / `mov rdx, 20` / `mov rdx, 30` — замените числа (например на `-5`, `123`, `0`).
3. Добавьте дополнительные элементы копированием блока:
	```nasm
	lea rcx, [rel array_ptr]
	mov rdx, <VALUE>
	call push_element
	```
4. Измените индекс в `remove_at` / `insert_at` (регистр `RDX` для Windows) на нужный.
5. Сохраните файл и выполните сборку.

## Сборка
Есть два способа: скрипт `build.sh` или `Makefile`.

### Windows (MSYS2 / Git Bash)
```bash
bash build.sh
```
Скрипт:
- Очищает старые объектные файлы.
- Ассемблирует `main_windows.asm` и `array_lib.asm` (`nasm -f win64`).
- Линкует через `gcc` к `msvcrt` и `kernel32`.
- Запускает `./test_program.exe`.

### Linux
При запуске скрипта в среде Linux он выберет ветку `build_linux`.
```bash
bash build.sh
```
Либо вручную:
```bash
nasm -f elf64 main_linux.asm -o main.o
nasm -f elf64 array_lib.asm -o array_lib.o
gcc main.o array_lib.o -o test_program
./test_program
```

### Makefile (кроссплатформенный)
```bash
make
```
Make автоматически выбирает формат (win64/elf64) по переменной `OS`.

## Пример ожидаемого вывода (Windows)
```
after new
after push 1
after push 2
after push 3
after remove
after insert
after sum
min_array result: 10
max_array result: 30
min=10 max=30
free_array entry: 0x............
free_array exit:  0x............
after free
```
Минимум/максимум будут зависеть от ваших изменений.

## Пример ожидаемого вывода (Linux)
```
[Linux] Start
[Linux] After new_array
[Linux] After push 1
[Linux] After push 2
[Linux] After push 3
[Linux] After remove
[Linux] After insert
[Linux] After sum
min_array result: 10
max_array result: 30
[Linux] After min
[Linux] After max
[Linux] After free
```
Отладочные сообщения `[Linux] ...` выводятся через `write` syscall в `main_linux.asm`.

## Проверка корректности
1. Измените набор значений, пересоберите — проверьте, что `min` действительно минимальный, а `max` максимальный.
2. Удалите элемент и убедитесь, что он исчез.
3. Вставьте элемент на позицию 0 — проверьте смещение остальных.
4. Вызовите `sum_array` после модификаций и manually посчитайте сумму.
5. Прогоните тест с пустым массивом (закомментируйте все `push_element`) — `min_array` и `max_array` вернут 0 (можете изменить поведение при желании).

## Расширение API (идеи)
- Реализовать `fill_array(ptr, value)` — записать `value` во все элементы.
- `find_value(ptr, value)` — линейный поиск, вернуть индекс или -1.
- `copy_array(ptr)` — выделить новый блок, скопировать данные.
- `sort_array(ptr)` — пузырьковая или более эффективная сортировка.
- Добавить проверку выхода за пределы и коды ошибок (например, возвращать -1 в RAX при ошибках).

## Тонкости ABI (Windows)
- Параметры: RCX, RDX, R8, R9 (остальные через стек, не используется здесь).
- Перед вызовом функций CRT (`malloc`, `free`, `printf`) необходимо корректное выравнивание стека по 16 байт.
- Тень (shadow space) 32 байта зарезервирована в вызывающей функции — текущая реализация использует локальное `sub rsp, 32` перед вызовами.
- Callee-saved регистры (RBX, RBP, RDI, RSI, R12–R15) сохраняются при необходимости.

## Тонкости ABI (Linux)
- Параметры: RDI, RSI, RDX, RCX, R8, R9 (остальные через стек).
- Для varargs функций (например `printf`) перед вызовом нужно установить `AL` в 0 (количество векторных регистров): `xor eax, eax`.
- Выравнивание стека по 16 байт обязательно перед вызовом функций — `push rbp; mov rbp, rsp` в начале функции обеспечивает это.
- Callee-saved регистры: RBX, RBP, R12–R15.

## Кроссплатформенная компиляция
Библиотека использует условные макросы NASM для автоматической адаптации:
```nasm
%ifidni __OUTPUT_FORMAT__, win64
%define IS_WIN64 1
%else
%define IS_WIN64 0
%endif
```
Все функции проверяют `IS_WIN64` и используют соответствующие регистры и calling conventions.

## Частые проблемы
Частые проблемы и подходы к решению:

- Segmentation fault после `free_array`:
	- Причина: нарушено выравнивание стека или не восстановлен сохранённый регистр.
	- Решение: проверить парность `push/pop`, корректность `sub/add rsp`, выравнивание `rsp % 16 == 0` перед вызовами `malloc/free/printf`.

- Неверный min/max:
	- Причина: переданы неправильные значения в `push_element` (например, знак или перепутан порядок аргументов).
	- Решение: сверить загрузку регистров в `main_windows.asm` перед вызовом (`RCX = &ptr`, `RDX = value`).

- Ничего не выводится:
	- Причина: ошибка сборки или отсутствие нужных библиотек (`msvcrt`).
	- Решение: убедиться в наличии `gcc`, `nasm`, пересобрать (`bash build.sh`), проверить что исполняемый файл запускается без ошибок.

- Одинаковые значения min и max (например `min=30 max=30` при разных элементах):
	- Причина: при вызове `printf` значение min в `RDX` было перезаписано вторым вызовом `max_array` (clobber аргумента), из-за чего оба аргумента стали одинаковыми.
	- Решение: сначала вызвать `min_array`, сохранить результат в памяти или неперезаписываемом регистре/переменной (`min_tmp`), затем вызвать `max_array` и только потом загрузить сохранённый min в `RDX` перед `printf` (как в обновлённом `main_windows.asm`).

- Segmentation fault на Linux при вызове функций библиотеки:
	- Причина: несоответствие calling convention (например, функция ожидает параметр в RDI, а передаётся в RCX).
	- Решение: убедиться, что `array_lib.asm` скомпилирован с `-f elf64` (NASM автоматически установит `__OUTPUT_FORMAT__` в `elf64`, активируя SysV ABI). Проверить, что в `main_linux.asm` используется `global main` (не `_start`) для корректной линковки с gcc.

- Краш внутри `printf` на Linux:
	- Причина: не установлен регистр `AL` в 0 перед вызовом varargs функции.
	- Решение: добавить `xor eax, eax` перед `call printf` в Linux-ветках кода.

## Как изменить поведение min/max для пустого массива
Сейчас для пустого или NULL массива возвращается 0. Варианты изменения:
1. Вернуть специальное значение: заменить `xor eax,eax` на `mov eax,0xFFFFFFFF` (для -1) в метках `.min_ret_zero` и `.max_ret_zero`.
2. Добавить глобальный флаг ошибки: сохранить 1 в некоторой глобальной переменной.

## Уборка диагностического вывода
В `array_lib.asm` присутствуют форматные строки и вызовы `printf` для логирования:
- `free_array`: логирует вход/выход с адресом указателя
- `resize_array`: логирует старый указатель и новую ёмкость (только Windows)
- `min_array`: логирует найденное минимальное значение
- `max_array`: логирует найденное максимальное значение

Для чистой релиз-сборки можно удалить:
1. Блоки между комментариями `; log entry` / `; log exit` / `; log result` в функциях
2. Форматные строки в секции `.data` (`fmt_free_entry`, `fmt_free_exit`, `fmt_resize_entry`, `fmt_resize_exit`, `fmt_min_result`, `fmt_max_result`)
3. Отладочные `write` syscall в `main_linux.asm` (сообщения `[Linux] ...`)

Либо добавить макро-флаг `ENABLE_LOGGING` для условной компиляции.

## Быстрый чек-лист изменений значений
1. Правите числа в `mov rdx, <value>` для `push_element`.
2. Меняете индекс в `mov rdx, <index>` перед `remove_at` / `insert_at`.
3. Пересобираете: `bash build.sh`.
4. Проверяете строки `min=..., max=...`.

## Лицензия / использование


---
Готово. При необходимости реализую недостающие функции (`fill_array`, `find_value`, `copy_array`, `sort_array`). Напишите, если нужно добавить их или убрать логирование.