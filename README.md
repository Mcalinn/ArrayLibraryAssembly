# Array Library (ASM x86-64)

Небольшая динамическая библиотека на ассемблере для работы с массивом 32‑битных целых чисел (uint32_t). Реализовано: создание, добавление, вставка, удаление, вычисление суммы, поиск минимума/максимума и освобождение памяти. Код адаптирован под Windows (Win64 ABI, аргументы в RCX/RDX/R8/R9). В Linux используется SysV ABI (аргументы в RDI/RSI/RDX/R10 и т.д.).

## Структура в памяти
```
offset 0  (8 байт)  size     (uint64_t, текущее количество элементов)
offset 8  (8 байт)  capacity (uint64_t, максимально доступное кол-во элементов без расширения)
offset 16 (данные)  data[]   (последовательность uint32_t чисел)
```

## Базовые типы
```
Array* указывает на начало блока (size по смещению 0).
```

## Реализованные функции (Windows сигнатуры)
Ниже показано, какие регистры занимают параметры в Windows x64 ABI.

Функции (Windows x64 ABI):

- new_array(capacity)
	- Назначение: создать новый массив (capacity=0 => 4 по умолчанию)
	- Параметры: RCX = capacity (uint64)
	- Возврат: RAX = Array* или 0 при ошибке

- free_array(ptr)
	- Назначение: освободить память массива
	- Параметры: RCX = Array*
	- Возврат: нет

- resize_array(old_ptr, new_capacity)
	- Назначение: изменить емкость, возможно переместив буфер
	- Параметры: RCX = старый Array*, RDX = новая capacity (uint64)
	- Возврат: RAX = новый Array* или 0 при ошибке

- push_element(&ptr, value)
	- Назначение: добавить элемент в конец; при нехватке места расширяет
	- Параметры: RCX = адрес переменной с указателем (Array**), RDX = значение (uint32)
	- Возврат: нет

- insert_at(&ptr, index, value)
	- Назначение: вставить элемент по индексу (если index > size, вставка в конец)
	- Параметры: RCX = Array**, RDX = index (uint64), R8D = value (uint32)
	- Возврат: нет

- remove_at(&ptr, index)
	- Назначение: удалить элемент по индексу (ничего не делает если index >= size)
	- Параметры: RCX = Array**, RDX = index (uint64)
	- Возврат: нет

- sum_array(ptr)
	- Назначение: посчитать сумму всех элементов
	- Параметры: RCX = Array*
	- Возврат: RAX = сумма (uint64)

- min_array(ptr)
	- Назначение: найти минимальный элемент (0 если пусто/NULL)
	- Параметры: RCX = Array*
	- Возврат: RAX = min (uint32)

- max_array(ptr)
	- Назначение: найти максимальный элемент (0 если пусто/NULL)
	- Параметры: RCX = Array*
	- Возврат: RAX = max (uint32)

Примечание: `fill_array`, `find_value`, `copy_array`, `sort_array` упомянуты ранее, но в текущем коде не реализованы / экспортируются дважды (артефакт). Если нужны — их можно добавить аналогично.

## Реализация на Linux
В `main_linux.asm` используются регистры SysV ABI:
| Функция      | Параметры (Linux)                       |
|--------------|-----------------------------------------|
| new_array    | RDI = capacity                          |
| push_element | RDI = Array**, ESI = value              |
| insert_at    | RDI = Array**, RSI = index, EDX = value |
| remove_at    | RDI = Array**, RSI = index              |
| sum_array    | RDI = Array*                            |
| free_array   | RDI = Array*                            |

## Добавление / изменение данных (Windows)
В `main_windows.asm` сейчас последовательно выполняется:
```
push_element(&array_ptr, 10)
push_element(&array_ptr, 20)
push_element(&array_ptr, 30)
remove_at(&array_ptr, 1)        ; удаляет значение 20
insert_at(&array_ptr, 1, 25)    ; вставляет 25 на позицию 1
sum_array(array_ptr)
min_array(array_ptr)
max_array(array_ptr)
free_array(array_ptr)
```
Чтобы протестировать другие значения:
1. Откройте `main_windows.asm`.
2. Найдите блоки:
	- `mov rdx, 10` / `mov rdx, 20` / `mov rdx, 30` — замените числа (например на `-5`, `123`, `0`).
3. Добавьте дополнительные элементы копированием блока:
	```nasm
	lea rcx, [rel array_ptr]
	mov rdx, <VALUE>
	call push_element
	```
4. Измените индекс в `remove_at` / `insert_at` (регистр `RDX` для Windows) на нужный.
5. Сохраните файл и выполните сборку.

## Сборка
Есть два способа: скрипт `build.sh` или `Makefile`.

### Windows (MSYS2 / Git Bash)
```bash
bash build.sh
```
Скрипт:
- Очищает старые объектные файлы.
- Ассемблирует `main_windows.asm` и `array_lib.asm` (`nasm -f win64`).
- Линкует через `gcc` к `msvcrt` и `kernel32`.
- Запускает `./test_program.exe`.

### Linux
При запуске скрипта в среде Linux он выберет ветку `build_linux`.
```bash
bash build.sh
```
Либо вручную:
```bash
nasm -f elf64 main_linux.asm -o main.o
nasm -f elf64 array_lib.asm -o array_lib.o
gcc main.o array_lib.o -o test_program
./test_program
```

### Makefile (кроссплатформенный)
```bash
make
```
Make автоматически выбирает формат (win64/elf64) по переменной `OS`.

## Пример ожидаемого вывода (Windows)
```
after new
after push 1
after push 2
after push 3
after remove
after insert
after sum
min_array dbg: size=3 first=10   ; (появится, если включён отладочный вывод в min_array)
min=10 max=30
free_array entry: 0x............
free_array exit:  0x............
after free
```
Минимум/максимум будут зависеть от ваших изменений.

## Проверка корректности
1. Измените набор значений, пересоберите — проверьте, что `min` действительно минимальный, а `max` максимальный.
2. Удалите элемент и убедитесь, что он исчез.
3. Вставьте элемент на позицию 0 — проверьте смещение остальных.
4. Вызовите `sum_array` после модификаций и manually посчитайте сумму.
5. Прогоните тест с пустым массивом (закомментируйте все `push_element`) — `min_array` и `max_array` вернут 0 (можете изменить поведение при желании).

## Расширение API (идеи)
- Реализовать `fill_array(ptr, value)` — записать `value` во все элементы.
- `find_value(ptr, value)` — линейный поиск, вернуть индекс или -1.
- `copy_array(ptr)` — выделить новый блок, скопировать данные.
- `sort_array(ptr)` — пузырьковая или более эффективная сортировка.
- Добавить проверку выхода за пределы и коды ошибок (например, возвращать -1 в RAX при ошибках).

## Тонкости ABI (Windows)
- Параметры: RCX, RDX, R8, R9 (остальные через стек, не используется здесь).
- Перед вызовом функций CRT (`malloc`, `free`, `printf`) необходимо корректное выравнивание стека по 16 байт.
- Тень (shadow space) 32 байта зарезервирована в вызывающей функции — текущая реализация использует локальное `sub rsp, 32` перед вызовами.
- Callee-saved регистры (RBX, RBP, RDI, RSI, R12–R15) сохраняются при необходимости.

## Частые проблемы
Частые проблемы и подходы к решению:

- Segmentation fault после `free_array`:
	- Причина: нарушено выравнивание стека или не восстановлен сохранённый регистр.
	- Решение: проверить парность `push/pop`, корректность `sub/add rsp`, выравнивание `rsp % 16 == 0` перед вызовами `malloc/free/printf`.

- Неверный min/max:
	- Причина: переданы неправильные значения в `push_element` (например, знак или перепутан порядок аргументов).
	- Решение: сверить загрузку регистров в `main_windows.asm` перед вызовом (`RCX = &ptr`, `RDX = value`).

- Ничего не выводится:
	- Причина: ошибка сборки или отсутствие нужных библиотек (`msvcrt`).
	- Решение: убедиться в наличии `gcc`, `nasm`, пересобрать (`bash build.sh`), проверить что исполняемый файл запускается без ошибок.

- Одинаковые значения min и max (например `min=30 max=30` при разных элементах):
	- Причина: при вызове `printf` значение min в `RDX` было перезаписано вторым вызовом `max_array` (clobber аргумента), из-за чего оба аргумента стали одинаковыми.
	- Решение: сначала вызвать `min_array`, сохранить результат в памяти или неперезаписываемом регистре/переменной (`min_tmp`), затем вызвать `max_array` и только потом загрузить сохранённый min в `RDX` перед `printf` (как в обновлённом `main_windows.asm`).

## Как изменить поведение min/max для пустого массива
Сейчас для пустого или NULL массива возвращается 0. Варианты изменения:
1. Вернуть специальное значение: заменить `xor eax,eax` на `mov eax,0xFFFFFFFF` (для -1) в метках `.min_ret_zero` и `.max_ret_zero`.
2. Добавить глобальный флаг ошибки: сохранить 1 в некоторой глобальной переменной.

## Уборка диагностического вывода
В `array_lib.asm` присутствуют форматные строки и вызовы `printf` для логирования (`free_array`, `resize_array`). Можно удалить эти блоки для чистой релиз-сборки — уберите соответствующие `lea rcx,... / call printf` и секцию форматных строк.

## Быстрый чек-лист изменений значений
1. Правите числа в `mov rdx, <value>` для `push_element`.
2. Меняете индекс в `mov rdx, <index>` перед `remove_at` / `insert_at`.
3. Пересобираете: `bash build.sh`.
4. Проверяете строки `min=..., max=...`.

## Лицензия / использование


---
Готово. При необходимости реализую недостающие функции (`fill_array`, `find_value`, `copy_array`, `sort_array`). Напишите, если нужно добавить их или убрать логирование.